"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const moment = require("moment-timezone");
const auto_decode_1 = require("./decoder/auto-decode");
const mysensors_mqtt_1 = require("./decoder/mysensors-mqtt");
const mysensors_serial_1 = require("./decoder/mysensors-serial");
const mysensors_msg_1 = require("./mysensors-msg");
const mysensors_types_1 = require("./mysensors-types");
const nullcheck_1 = require("./nullcheck");
class MysensorsController {
    constructor(database, handleIds, timeResponse, timeZone, measurementSystem, mqttRoot) {
        this.database = database;
        this.handleIds = handleIds;
        this.timeResponse = timeResponse;
        this.timeZone = timeZone;
        this.measurementSystem = measurementSystem;
        this.mqttRoot = mqttRoot;
    }
    messageHandler(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            msg = yield auto_decode_1.AutoDecode(msg);
            if (nullcheck_1.NullCheck.isDefinedOrNonNull(msg.nodeId)) {
                yield this.database.nodeHeard(msg.nodeId);
                if (nullcheck_1.NullCheck.isDefinedOrNonNull(msg.childSensorId)) {
                    yield this.database.childHeard(msg.nodeId, msg.childSensorId);
                }
            }
            if (msg.messageType === mysensors_types_1.mysensor_command.C_PRESENTATION &&
                nullcheck_1.NullCheck.isDefinedOrNonNull(msg.childSensorId) &&
                nullcheck_1.NullCheck.isDefinedOrNonNull(msg.nodeId) &&
                nullcheck_1.NullCheck.isDefinedOrNonNull(msg.subType)) {
                yield this.database.child(msg.nodeId, msg.childSensorId, msg.subType, msg.payload);
            }
            if (msg.messageType === mysensors_types_1.mysensor_command.C_INTERNAL) {
                switch (msg.subType) {
                    case mysensors_types_1.mysensor_internal.I_ID_REQUEST:
                        return this.encode(yield this.handleIdRequest(msg));
                    case mysensors_types_1.mysensor_internal.I_SKETCH_NAME:
                    case mysensors_types_1.mysensor_internal.I_SKETCH_VERSION:
                        yield this.handleSketchVersion(msg);
                        break;
                    case mysensors_types_1.mysensor_internal.I_LOG_MESSAGE:
                        yield this.handleDebug(msg);
                        break;
                    case mysensors_types_1.mysensor_internal.I_TIME:
                        return this.encode(yield this.handleTimeResponse(msg));
                    case mysensors_types_1.mysensor_internal.I_CONFIG:
                        return this.encode(yield this.handleConfig(msg));
                }
            }
        });
    }
    handleConfig(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.measurementSystem !== 'N') {
                msg.payload = this.measurementSystem;
                return msg;
            }
        });
    }
    handleTimeResponse(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            msg.subType = mysensors_types_1.mysensor_internal.I_TIME;
            if (this.timeResponse && msg.messageType) {
                const offset = this.getTzOffsetSeconds();
                let sec = Number(moment().tz(this.timeZone).format('X'));
                sec = sec + offset;
                msg.payload = sec.toString();
                return msg;
            }
        });
    }
    getTzOffsetSeconds() {
        const tzData = moment().tz(this.timeZone).format('Z').split(':');
        let seconds = (Number(tzData[0].substr(1)) * 60 + Number(tzData[1])) * 60;
        if (tzData[0].substr(0, 1) === '-') {
            seconds = seconds * -1;
        }
        return seconds;
    }
    handleIdRequest(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            msg.subType = mysensors_types_1.mysensor_internal.I_ID_RESPONSE;
            if (this.handleIds) {
                msg.payload = (yield this.database.getFreeNodeId()).toString();
                return msg;
            }
        });
    }
    handleDebug(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = /TSF:MSG:READ,(\d+)-(\d+)-(\d+)/;
            const m = r.exec(msg.payload);
            if (nullcheck_1.NullCheck.isDefinedOrNonNull(m)) {
                this.database.setParent(m[1], m[2]);
            }
        });
    }
    handleSketchVersion(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (msg.subType === mysensors_types_1.mysensor_internal.I_SKETCH_VERSION && msg.nodeId) {
                this.database.sketchVersion(msg.nodeId, msg.payload);
            }
            else if (msg.subType === mysensors_types_1.mysensor_internal.I_SKETCH_NAME && msg.nodeId) {
                this.database.sketchName(msg.nodeId, msg.payload);
            }
        });
    }
    encode(msg) {
        let encoder;
        if (nullcheck_1.NullCheck.isDefinedOrNonNull(msg)) {
            msg.topicRoot = this.mqttRoot;
            if (msg.origin === mysensors_msg_1.MsgOrigin.serial) {
                encoder = new mysensors_serial_1.MysensorsSerial();
            }
            else if (msg.origin === mysensors_msg_1.MsgOrigin.mqtt) {
                encoder = new mysensors_mqtt_1.MysensorsMqtt();
            }
        }
        if (encoder === undefined || msg === undefined) {
            return msg;
        }
        return encoder.encode(msg);
    }
}
exports.MysensorsController = MysensorsController;
