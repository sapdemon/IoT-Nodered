"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const auto_decode_1 = require("../lib/decoder/auto-decode");
const mysensors_debug_1 = require("../lib/mysensors-debug");
const mysensors_types_1 = require("../lib/mysensors-types");
const nullcheck_1 = require("../lib/nullcheck");
module.exports = (RED) => {
    RED.nodes.registerType('mysdebug', function (config) {
        RED.nodes.createNode(this, config);
        this.mysDbg = new mysensors_debug_1.MysensorsDebugDecode();
        this.on('input', (msg) => __awaiter(this, void 0, void 0, function* () {
            msg = yield auto_decode_1.AutoDecode(msg);
            if (nullcheck_1.NullCheck.isDefinedOrNonNull(msg.nodeId)) {
                let msgHeader = '';
                let msgSubType = null;
                if (nullcheck_1.NullCheck.isDefinedOrNonNull(msg.subType)) {
                    switch (msg.messageType) {
                        case mysensors_types_1.mysensor_command.C_PRESENTATION:
                            msgHeader = 'PRESENTATION';
                            msgSubType = mysensors_types_1.mysensor_sensor[msg.subType];
                            break;
                        case mysensors_types_1.mysensor_command.C_SET:
                            msgHeader = 'SET';
                            msgSubType = mysensors_types_1.mysensor_data[msg.subType];
                            break;
                        case mysensors_types_1.mysensor_command.C_REQ:
                            msgHeader = 'REQ';
                            msgSubType = mysensors_types_1.mysensor_data[msg.subType];
                            break;
                        case mysensors_types_1.mysensor_command.C_INTERNAL:
                            if (msg.subType === 9) {
                                msg.payload = this.mysDbg.decode(msg.payload);
                            }
                            else {
                                msgHeader = 'INTERNAL';
                                msgSubType = mysensors_types_1.mysensor_internal[msg.subType];
                            }
                            break;
                        case mysensors_types_1.mysensor_command.C_STREAM:
                            msgHeader = 'STREAM';
                            msgSubType = mysensors_types_1.mysensor_stream[msg.subType];
                            break;
                        default:
                            msg.payload = 'unsupported msgType ' + msg.messageType;
                            break;
                    }
                }
                if (msgSubType != null) {
                    msg.payload = msgHeader +
                        ';nodeId:' + msg.nodeId +
                        ';childId:' + msg.childSensorId +
                        ';SubType:' + msgSubType +
                        ';ACK:' + msg.ack +
                        ';Payload:' + msg.payload;
                }
            }
            this.send(msg);
        }));
    });
};
