"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const mysensors_controller_1 = require("../lib/mysensors-controller");
module.exports = (RED) => {
    RED.nodes.registerType('myscontroller', function (props) {
        RED.nodes.createNode(this, props);
        if (props.database) {
            this.database = RED.nodes.getNode(props.database);
            if (this.database.database) {
                this.controller = new mysensors_controller_1.MysensorsController(this.database.database, props.handleid || false, props.timeresponse || true, props.timezone || 'UTC', props.measurementsystem || 'M', props.mqttroot || 'mys-out');
                this.on('input', (msg) => {
                    (this.controller).messageHandler(msg).then((msgOut) => {
                        this.send(msgOut);
                    });
                });
            }
        }
    });
    RED.httpAdmin.get('/mysensornodes/:database', RED.auth.needsPermission(''), (req, res) => __awaiter(this, void 0, void 0, function* () {
        const dbNode = RED.nodes.getNode(req.params.database);
        if (dbNode.database) {
            const x = yield dbNode.database.getNodeList();
            res.json(JSON.stringify({ data: x }));
        }
    }));
};
